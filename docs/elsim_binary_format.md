# Формат виконуваного файлу `elsim-bin`

Цей документ описує мінімальний бінарний формат виконуваного файлу для симулятора **Embedded Linux Device Simulator** (далі - `elsim`). Формат призначений для завантаження програми в пам’ять плати та подальшого виконання на **FakeCpu**.

Версія формату: **v0 (початкова, мінімальна)**.

---

## 1. Загальна ідея

Файл формату `elsim-bin` містить:

1. Невеликий **заголовок** з метаданими:
   - магічне число (ідентифікатор формату)
   - стартова адреса виконання (entry point)
   - розмір програми в байтах
2. **Послідовний блок машинного коду** для FakeCpu.

Ніяких секцій, таблиць символів, релокацій, окремих сегментів даних тощо в цій версії формату **немає**. Увесь вміст після заголовка інтерпретується як машинний код.

---

## 2. Базові припущення

Формат `elsim-bin` ґрунтується на таких припущеннях:

- Адреси та розміри:
  - використовуються **32-бітні беззнакові цілі** (`uint32_t`);
- Порядок байтів:
  - усі багатобайтові поля зберігаються в **little-endian**;
- Машинний код:
  - інструкції FakeCpu мають розмір **4 байти (32 біти)**;
  - `code_size` у заголовку задається в **байтах**, а не в кількості інструкцій;
- Програма містить лише код:
  - дані (якщо потрібні) можуть бути закодовані безпосередньо всередині машинного коду або в пам’яті, ініціалізованій інструкціями.

---

## 3. Структура файлу

Файл складається з:

1. Заголовка фіксованого розміру (12 байт).
2. Блоку машинного коду змінного розміру.

У загальному вигляді:

| Offset | Вміст                         |
|--------|-------------------------------|
| 0x00   | Заголовок (12 байт):          |
|        | • magic (4 байти)             |
|        | • entry_point (4 байти)       |
|        | • code_size (4 байти)         |
| 0x0C   | Блок коду (code_size байтів)  |

## 4. Формат заголовка
### 4.1. Таблиця полів
| Поле |  Тип   |Offset   |  Розмір   |  Опис  |
|------|--------|---------|-----------|--------|
|`magic` |`uint32_t`| 0x00    |     4     |Магічне число, яке ідентифікує формат `elsim-bin`|
|`entry_point`|`uint32_t`| 0x04    |     4     |Стартова адреса виконання (початкове значення PC)|
|`code_size`|`uint32_t`| 0x08    |     4     |Розмір блоку машинного коду в байтах|

Усі поля зберігаються в little-endian.

### 4.2. C++-структура заголовка
```cpp
#pragma pack(push, 1)
struct ElsimBinaryHeader
{
    uint32_t magic;       // 'ELSB' у little-endian
    uint32_t entry_point; // Стартова адреса виконання (PC)
    uint32_t code_size;   // Розмір блоку коду в байтах, що йде після заголовка
};
#pragma pack(pop)
```
У реалізації рекомендовано явно контролювати вирівнювання (`#pragma pack` або `static_assert(sizeof(ElsimBinaryHeader) == 12)`), щоб гарантувати відповідність бінарного формату.

## 5. Опис полів заголовка
### 5.1. Магічне число `magic`
Поле `magic` використовується, щоб відрізнити файл формату `elsim-bin` від інших файлів.
- Текстове представлення: `"ELSB"` (ELSim Binary).
- У байтах (ASCII):
```bash
'E' = 0x45
'L' = 0x4C
'S' = 0x53
'B' = 0x42
```
У файлі, в порядку зберігання (little-endian `uint32_t`):

```bash
45 4C 53 42
```
- Як значення `uint32_t` у little-endian це буде: `0x42534C45`.

Під час завантаження файлу, loader обов’язково перевіряє:

```bash
if (header.magic != 0x42534C45) {
    // Помилка: непідтримуваний/пошкоджений формат
}
```
### 5.2. Стартова адреса `entry_point`
Поле `entry_point` задає:

- початкове значення PC (Program Counter) для FakeCpu;
- базову адресу завантаження коду у поточній версії формату.

Правило v0:
- Блок коду завантажується в пам’ять починаючи з адреси `entry_point`.
- Перший байт коду → адреса `entry_point`, другий → `entry_point + 1`, і т.д.

Таким чином, `entry_point` одночасно визначає:
- адресу, з якої CPU починає виконання,
- адресу, з якої в пам’ять записується перший байт програми.

У майбутніх розширеннях формату можливий поділ на:

- окреме поле адреси завантаження
- та окреме поле entry point, але в поточній версії це одне поле.

### 5.3. Розмір програми `code_size`
Поле `code_size` містить:

- кількість байтів, які складають блок машинного коду після заголовка;
- не включає сам заголовок (тобто загальний розмір файлу = `sizeof(header) + code_size`).

Рекомендовані перевірки:

- `code_size > 0`
- `code_size % 4 == 0` (кратність розміру інструкції FakeCpu)
- `entry_point + code_size` не виходить за межі доступної RAM плати, описаної в `board.yaml`.

## 6. Блок машинного коду
Після заголовка одразу йде блок машинного коду:
```bash
Offset  Опис
0x0C    Перший байт коду
...
0x0C + code_size - 1  Останній байт коду
```
Код інтерпретується як послідовність інструкцій FakeCpu:

- розмір інструкції - 4 байти;
- FakeCpu читає інструкції через свій інтерфейс до `MemoryBus` (наприклад, `FETCH32`).

Формат інструкцій визначається окремим документом ISA (наприклад, `docs/fakecpu_isa.md`) і не є частиною цього опису.

## 7. Алгоритм завантаження `elsim-bin` у пам’ять
Нижче наведено загальну логіку завантаження виконуваного файлу у RAM плати для подальшого виконання.

### 7.1. Кроки завантаження
1. Відкрити файл у двійковому режимі.

2. Прочитати заголовок розміром 12 байт у структуру `ElsimBinaryHeader`.

3. Перевірити магічне число:

     - якщо `header.magic != 0x42534C45`, вважати файл непідтримуваним/пошкодженим.

4. Перевірити `code_size`:

    - `code_size > 0`;
    - (опційно) `code_size % 4 == 0`;
    - (опційно) `entry_point + code_size` поміщається в доступний діапазон RAM згідно з конфігурацією плати.

5. Прочитати блок коду:

    - створити буфер `std::vector<std::uint8_t> code(header.code_size);`
    - прочитати `header.code_size` байтів з файлу.

6. Завантажити байти в `MemoryBus`:

    - байт `code[0]` → адреса `header.entry_point`,
    - байт `code[i]` → адреса `header.entry_point + i`.

7. Ініціалізувати CPU:

    - встановити `PC = header.entry_point`;
    - ініціалізувати регістри (R0–R7), FLAGS та інші стани згідно з Execution Model FakeCpu.

8. Розпочати виконання програми:

    - передати керування внутрішньому циклу виконання CPU.

### 7.2. Псевдокод завантажувача
```cpp
bool loadElsimBinary(const std::string& path, MemoryBus& memory, Cpu& cpu)
{
    std::ifstream in(path, std::ios::binary);
    if (!in) {
        // Помилка: файл не вдалося відкрити
        return false;
    }

    ElsimBinaryHeader header{};
    in.read(reinterpret_cast<char*>(&header), sizeof(header));
    if (in.gcount() != sizeof(header)) {
        // Помилка: файл занадто короткий
        return false;
    }

    // Перевірка магічного числа
    constexpr uint32_t ELSIM_MAGIC = 0x42534C45; // 'ELSB'
    if (header.magic != ELSIM_MAGIC) {
        // Помилка: непідтримуваний формат
        return false;
    }

    if (header.code_size == 0) {
        // Помилка: порожня програма
        return false;
    }

    // (Опційно) перевірка кратності довжини інструкції
    if (header.code_size % 4 != 0) {
        // Ворнінг або помилка залежно від політики
    }

    // Прочитати машинний код
    std::vector<uint8_t> code(header.code_size);
    in.read(reinterpret_cast<char*>(code.data()), header.code_size);
    if (static_cast<uint32_t>(in.gcount()) != header.code_size) {
        // Помилка: файл обірваний
        return false;
    }

    // Завантажити код у память починаючи з entry_point

    uint32_t base = header.entry_point;
    for (uint32_t i = 0; i < header.code_size; ++i) {
        memory.write8(base + i, code[i]);
    }

    // Ініціалізувати CPU
    cpu.reset();              // встановлює регістри/FLAGS в початковий стан
    cpu.setPC(header.entry_point);

    return true;
}
```

Примітка: реальний інтерфейс до `MemoryBus` та `Cpu` у проєкті `elsim` може відрізнятися, наведений код є лише ілюстрацією.

## 8. Приклад файлу `elsim-bin`
Розглянемо уявну програму з двох інструкцій (по 4 байти, разом 8 байт):

```bash
Адреса  Код (hex)        Коментар (умовний)
0x1000  01 00 10 00      ; умовна інструкція 1 (наприклад, LOAD R0, [0x0010])
0x1004  FF 00 00 00      ; умовна інструкція 2 (наприклад, HALT)
```
Для цієї програми:

- `magic` = `'ELSB'` → байти: `45 4C 53 42`
- `entry_point` = `0x00001000` → little-endian: `00 10 00 00`
- `code_size` = `8` байт → little-endian: `08 00 00 00`

Повний вміст файлу в hex:

```bash
Header:
45 4C 53 42          ; magic = 'ELSB'
00 10 00 00          ; entry_point = 0x00001000
08 00 00 00          ; code_size   = 8 байт

Code:
01 00 10 00          ; інструкція 1
FF 00 00 00          ; інструкція 2
```
Поведінка loader’а:

1. Читає заголовок, перевіряє магічне число та `code_size`.
2. Завантажує 8 байтів коду в `MemoryBus`, починаючи з адреси `0x1000`.
3. Встановлює `PC = 0x1000`.
4. Запускає цикл виконання FakeCpu.

## 9. Можливі розширення формату (future work)
Поточна версія формату `elsim-bin` умисно робиться максимально простою. У майбутньому можливе розширення заголовка, наприклад:

- Поле версії формату:
    - `uint16_t version_major`, `uint16_t version_minor`;
- Окреме поле адреси завантаження:
    - `load_address` (адреса, куди завантажується код),
    - `entry_point` (адреса першої інструкції виконання, могла б відрізнятися);
- Секції:
    - код, дані, BSS, таблиця констант;
- Метадані:
    - розмір стека,
    - розмір heap,
    - інформація про сумісність ISA тощо.