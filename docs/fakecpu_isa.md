# FakeCPU ISA Specification

## 1. Overview

FakeCPU - це проста 32-бітна навчальна архітектура, створена спеціально для проєкту **Embedded Linux Device Simulator (ELSIM)**. Її мета - забезпечити мінімальний набір інструкцій і чітку модель виконання, достатню для тестування емулятора, пристроїв та майбутніх демонстраційних програм.

Ця специфікація описує:

- структуру регістрів FakeCPU,
- загальний формат інструкцій,
- набір базових інструкцій,
- семантику виконання,
- приклади програм.

FakeCPU не є реальною архітектурою, але наслідує багато концепцій з MIPS, ARM та RISC-V, що робить її простою для вивчення та розширення.

## 2. Global Architecture

### 2.1. Data model and address space

- FakeCPU є **32-бітною архітектурою**.
- Основний тип даних — **32-бітне слово (`uint32_t`)**.
- Пам’ять є **байт-орієнтованою**, тобто кожна адреса вказує на байт.
- Адресний простір — **32 біти**, можливі адреси від `0x00000000` до `0xFFFFFFFF`.
- Багатобайтові значення зберігаються у форматі **little-endian**.

### 2.2. Instruction size and alignment

- Кожна інструкція має фіксований розмір: **4 байти (32 біти)**.
- Значення регістра **PC завжди вказує на байтову адресу початку інструкції**.
- Після кожної інструкції (за винятком переходів та HALT) виконується:
```text
PC = PC + 4
```
- Використання фіксованого формату інструкцій значно спрощує декодування та реалізацію FakeCPU.

## 3. Register Set

FakeCPU має 11 архітектурно видимих 32-бітних регістрів:

- 8 загальних регістрів `R0–R7`,
- 3 спеціальні регістри (`PC`, `SP`, `FLAGS`).

Додатково в реалізації може використовуватися внутрішній тимчасовий регістр,
який не є частиною ISA і не доступний програмісту.

### 3.1. General-purpose registers

| Register | Description |
|----------|-------------|
| R0       | Загального призначення |
| R1       | Загального призначення |
| R2       | Загального призначення |
| R3       | Загального призначення |
| R4       | Загального призначення |
| R5       | Загального призначення |
| R6       | Загального призначення |
| R7       | Загального призначення |

Усі регістри є взаємозамінними й не мають спеціальних ролей. Значення можуть використовуватись у арифметичних операціях, адресації памʼяті та копіюванні даних.

### 3.2. Special registers

| Register | Description |
|----------|-------------|
| PC       | Program Counter — вказує адресу поточної інструкції |
| SP       | Stack Pointer — зарезервований для майбутніх інструкцій стеку |
| FLAGS    | Регістр прапорців — містить біти стану після операцій |

#### PC (Program Counter)

- Містить **байтову адресу** інструкції.
- Оновлюється після кожної інструкції (якщо немає переходу).

#### SP (Stack Pointer)

- Вказує на вершину стеку.
- У релізі **v0.2 не використовується**, але зарезервований у ISA.

### 3.3. FLAGS register

Прапорці займають молодші біти регістра:

| Bit | Name | Meaning |
|-----|------|---------|
| 0   | Z    | Zero flag — встановлюється, якщо результат = 0 |
| 1   | N    | Negative flag — встановлюється, якщо старший біт результату = 1 |
| 2   | C    | Carry flag — перенос при додаванні / позика при відніманні |
| 3   | V    | Overflow flag — переповнення signed-арифметики |

Біти `4–31` зарезервовані, завжди дорівнюють 0.

У релізі **v0.2 активно використовується лише прапорець Z**, інші можуть бути використані в майбутніх розширеннях ISA.

## 4. Instruction Encoding

### 4.1. Opcode layout

Кожна інструкція FakeCPU — це одне 32-бітне слово:
- Біти `31..24` — **opcode** (8 біт).
- Біти `23..0` — аргументи інструкції. Формат цих бітів залежить від типу інструкції.

Такий підхід дозволяє легко декодувати opcode:

```bash
opcode = instruction >> 24
```

### 4.2. Instruction types

Короткий опис типів інструкцій:

FakeCPU використовує чотири логічні типи інструкцій:

1. **R-type (Register)**  
   - Операції між регістрами  
   - Приклад: `ADD R1, R2`

2. **I-type (Immediate)**  
   - Операції з константою  
   - Приклад: `MOV R0, #5`, `ADD R3, #10`

3. **M-type (Memory)**  
   - Доступ до памʼяті через `[base + offset]`  
   - Приклад: `LOAD R0, [R1 + 4]`

4. **J-type (Jump)**  
   - PC-відносні переходи  
   - Приклад: `JZ -2`, `JMP +5`

### 4.3. Opcode table

| Instruction | Opcode |
|-------------|--------|
| MOV         | 0x01   |
| ADD         | 0x02   |
| SUB         | 0x03   |
| LOAD        | 0x04   |
| STORE       | 0x05   |
| JMP         | 0x06   |
| JZ          | 0x07   |
| JNZ         | 0x08   |
| HALT        | 0xFF   |

Усі інструкції мають розмір 4 байти і можуть бути закодовані в одне 32-бітне слово.

## 5. Instruction Set Reference

Усі інструкції FakeCPU:

- мають розмір 32 біти,

- використовують старший байт для opcode,

- після виконання переходів не інкрементують PC,

- інакше виконують `PC = PC + 4.`

### Позначення в цьому розділі:

- **Rd** — регістр-призначення
- **Rs** — регістр-джерело
- **imm16** — 16-бітний signed immediate
- **offset16** — 16-бітний signed offset (у словах для стрибків)
- **EA** — Effective Address (ефективна адреса)

### 5.1. MOV — Move
```bash
Opcode: 0x01
```
#### Syntax
```bash
MOV Rd, Rs
MOV Rd, #imm16
```
#### Description
Копіює значення з регістра або константи до регістра `Rd.`
#### Operands

- `Rd` — регістр призначення
- `Rs` — регістр-джерело
- `imm16` — signed immediate (sign-extended до 32 біт)

#### Pseudo-code
```bash
if form == MOV Rd, Rs:
    Rd = Rs
else:
    Rd = sign_extend(imm16)

FLAGS.Z = (Rd == 0)
FLAGS.N = (Rd[31] == 1)
FLAGS.C unchanged
FLAGS.V unchanged
```
#### Example
```bash
MOV R0, #5     ; R0 = 5
MOV R1, R0     ; R1 = 5
```
### 5.2. ADD — Add
```bash
Opcode: 0x02
```
#### Syntax
```bash
ADD Rd, Rs
ADD Rd, #imm16
```
#### Description
Додає значення регістра або константи до `Rd.`

#### Operands

- `Rd` — регістр призначення (також перший операнд)
- `Rs` / `imm16` — другий операнд

#### Pseudo-code
``` bash
src = Rs OR sign_extend(imm16)
old = Rd
tmp = (uint64)old + (uint64)src
result = (uint32)tmp

Rd = result

FLAGS.Z = (result == 0)
FLAGS.N = (result[31] == 1)
FLAGS.C = ((tmp >> 32) & 1)
FLAGS.V = signed_overflow_in_add(old, src, result)
```
#### Example
```bash
MOV R0, #10
ADD R0, #5     ; R0 = 15
ADD R1, R0     ; R1 = R1 + R0
```
### 5.3. SUB — Subtract
```bash
Opcode: 0x03
```
#### Syntax
```bash
SUB Rd, Rs
SUB Rd, #imm16
```
#### Description
Віднімає значення з `Rd` (Rd = Rd - operand).
#### Operands
- `Rd` — регістр призначення
- `Rs` / `imm16` — другий операнд

#### Pseudo-code
```bash
src = Rs OR sign_extend(imm16)
old = Rd
tmp = (uint64)old - (uint64)src
result = (uint32)tmp

Rd = result

FLAGS.Z = (result == 0)
FLAGS.N = (result[31] == 1)
FLAGS.C = (borrow_occurred ? 1 : 0)
FLAGS.V = signed_overflow_in_sub(old, src, result)
```
#### Example
```bash
MOV R0, #20
SUB R0, #3     ; R0 = 17
```
### 5.4. LOAD — Load word
```bash
Opcode: 0x04
```
#### Syntax
```bash
LOAD Rd, [Rs + imm16]
```
#### Description

Читає 32-бітне слово з пам’яті за адресою `(Rs + imm16)` та зберігає його в `Rd`.

#### Operands

- `Rd` — регістр-приймач
- `Rs` — base register
- `imm16` — signed byte offset

#### Pseudo-code
```bash
EA = Rs + sign_extend(imm16)
Rd = MEM32[EA]

FLAGS.Z = (Rd == 0)
FLAGS.N = (Rd[31] == 1)
FLAGS.C unchanged
FLAGS.V unchanged
```
#### Example
```bash
LOAD R0, [R1 + 4]
```
### 5.5. STORE — Store word
```bash
Opcode: 0x05
```
#### Syntax
```bash
STORE Rs, [Rd + imm16]
```
#### Description
Записує 32-бітне значення `Rs` у пам’ять за адресою `(Rd + imm16)`.

#### Operands
- `Rs` — значення для запису
- `Rd` — base register
- `imm16` — signed byte offset

#### Pseudo-code
```bash
EA = Rd + sign_extend(imm16)
MEM32[EA] = Rs

FLAGS unchanged
```
#### Example
```bahs
STORE R3, [R2 + 0]
```
### 5.6. JMP
```bash
Opcode: 0x06
```
#### Syntax
```bash
JMP offset16
```
#### Description
Виконує безумовний PC-relative перехід.

#### Operands
- `offset16` — signed offset у словах, не в байтах.

#### Pseudo-code
```bash
PC = PC + 4 + (sign_extend(offset16) << 2)
```
#### Example
```bash
JMP -2     ; перейти на дві інструкції назад
```
### 5.7. JZ — Jump if zero
```bash
Opcode: 0x07
```
#### Syntax
```bash
JZ offset16
```
#### Description
Виконує стрибок, якщо `FLAGS.Z == 1`.

#### Operands
- `offset16` — signed 16-bit word offset

#### Pseudo-code
```bash
if FLAGS.Z == 1:
    PC = PC + 4 + (sign_extend(offset16) << 2)
else:
    PC = PC + 4
```
#### Example
``` bash
JZ +3     ; якщо останній результат був 0, перескочити 3 інструкції вперед
```

### 5.8. JNZ — Jump if not zero
```bash
Opcode: 0x08
```
#### Syntax
```bash
JNZ offset16
```
#### Description
Стрибок, якщо `FLAGS.Z == 0`.

#### Pseudo-code
```bash
if FLAGS.Z == 0:
    PC = PC + 4 + (sign_extend(offset16) << 2)
else:
    PC = PC + 4
```
#### Example
```bash
JNZ -1     ; повторювати цикл, поки значення ≠ 0
```
### 5.9. HALT — Stop execution
```bash
Opcode: 0xFF
```
#### Syntax
```bash
HALT
```
#### Description
Зупиняє виконання процесора. Після цієї інструкції FakeCPU переходить у стан *halted*
і більше не виконує інструкцій.

#### Pseudo-code
```bash
CPU.state = HALTED
```
#### Example
```bash
HALT
```

## 6. Execution Model

Цей розділ описує базову модель виконання FakeCPU: початковий стан після `reset` та поведінку процесора після інструкції `HALT`.

### 6.1. Reset state

Після скидання (reset) FakeCPU переходить у визначений початковий стан:

- Усі загальні регістри обнулені:
  - `R0 = R1 = ... = R7 = 0`
- Лічильник команд встановлено в початок памʼяті програми:
  - `PC = 0x00000000`
- Регістр стеку обнулений:
  - `SP = 0x00000000`  
    (у поточній версії ISA стек не використовується, але регістр зарезервовано на майбутнє)
- Регістр прапорців очищений:
  - `FLAGS = 0x00000000`  
    (`Z = 0`, `N = 0`, `C = 0`, `V = 0`)

Ініціалізація памʼяті виконується **поза межами ISA** й залежить від середовища виконання (симулятора). Типовий сценарій:

1. Образ програми (послідовність 32-бітних інструкцій) завантажується в памʼять, починаючи з адреси `0x00000000`.
2. Дані програми (константи, змінні) розміщуються в інших ділянках адресного простору.
3. Після завантаження виконується `reset` CPU, після чого симулятор починає виконання з `PC = 0`.

### 6.2. Halted state

Інструкція `HALT` переводить FakeCPU у зупинений стан (*halted state*).

Після виконання `HALT`:

- процесор **припиняє вибірку та виконання інструкцій**;
- значення всіх регістрів (`R0–R7`, `PC`, `SP`, `FLAGS`) залишаються незмінними;
- подальша поведінка визначається симулятором:
  - зазвичай основний цикл емулювання зупиняється,
  - стан CPU може бути використаний для аналізу результатів (наприклад, читання значення певних регістрів або памʼяті).

У поточній версії ISA:

- `HALT` є єдиним механізмом коректного завершення програми,
- повторне «продовження» виконання після `HALT` не визначене на рівні ISA і залежить від реалізації симулятора (наприклад, повний reset або перезапуск з початковим станом).

## 7. Example Programs
У цьому розділі наведено приклади простих програм для демонстрації базових інструкцій FakeCPU.
Приклади записані у псевдо-асемблері, що відповідає моделі ISA, але не є формальним бінарним форматом.

---
### 7.1. Example 1: simple arithmetic

**Мета:**  
Обчислити значення `5 + 7`, зберегти результат у `R0`, після чого зупинити виконання.

**Program (pseudocode assembly):**
```bash
MOV R0, #5        ; R0 = 5
MOV R1, #7        ; R1 = 7
ADD R0, R1        ; R0 = R0 + R1 = 12
HALT
```
**Notes:**

- Інструкція `ADD R0, R1` оновлює прапорці, наприклад, `Z = 0`, `N = 0`.
- Після завершення програми `R0 = 12`.

---

### 7.2. Example 2: Countdown loop using memory

**Мета:**  
Є змінна `counter`, розміщена в памʼяті за адресою `0x100`.  
Потрібно виконати цикл, який зменшує її значення до нуля.  
Коли counter == 0 → програма завершується.

**Initial memory state:**
```bash
; MEM32[0x100] = 5    ; значення лічильника
```
**Program:**

```bash
; R1 = address of counter
    MOV   R1, #0x100


loop:
    LOAD  R0, [R1 + 0]     ; R0 = MEM32[0x100]
    SUB   R0, #1           ; R0 = R0 - 1
    STORE R0, [R1 + 0]     ; MEM32[0x100] = R0
    JZ    end              ; якщо результат == 0, вийти з циклу
    JMP   loop             ; інакше повторити
end:
    HALT                   ; завершити виконання
```
**Notes:**

- `LOAD` і `STORE` демонструють базову адресацію `[base + offset]`.
- `SUB` встановлює прапор `Z = 1`, коли результат дорівнює нулю.
- Після завершення програми:
  - `MEM32[0x100] = 0`,
  - виконання зупинено інструкцією `HALT`.

---